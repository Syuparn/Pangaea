{
  # A converts self into arr.
  A: m{|| @{\}},
  # acc returns each state of reducing process.
  acc: m{|f, init: nil|
    ._iter.{|it| <{|acc| yield f(acc, it.next) => res; recur(res)}>.new(init)}
  },
  # all? returns whether all elements meet the predicate f
  all?: m{|f| @^f@B.has?(false).!},
  # any? returns whether any element meets the predicate f
  any?: m{|f| @^f@B.has?(true)},
  # chain concatenates all iters in arguments.
  chain: m{
    iters := \0._iter
    <{|it|
      # NOTE: `yield if` cannot be used because it raises StopIterErr
      return next.val if (next := it.try.next).val?
      raise e if (e := next.err).type != StopIterErr
      # if StopIterErr is raised, use another iter
      nextIt := iters.next._iter
      yield nextIt.next
      recur(nextIt)
    }>.new(iters.next._iter)
  },
  # doUntil returns elements while (element_yielded_last).^cond? is false.
  doUntil: m{|cond?|
    ._iter.{|it| <{|ok| yield (n := it.next) if !ok; recur(n.^cond?)}>.new(false)}
  },
  # doWhile returns elements while (element_yielded_last).^cond? is true.
  doWhile: m{|cond?|
    ._iter.{|it| <{|ok| yield (n := it.next) if ok; recur(n.^cond?)}>.new(true)}
  },
  # empty? returns whether self contains elements.
  empty?: m{|| .A.empty?},
  # exclude selects elements for which f returns false.
  exclude: m{|f| @{\ if .proto == Arr else [\]}@{\.unwrap if !f(*\)}},
  # find returns the first element which cond? is true. (returns nil if not found)
  find: m{|cond?|
    ._iter
      # generated iter is [..., found] or _iter itself (if not found)
      |.{|it| <{|ok| yield (n := it.next) if !ok; recur(n.^cond?)}>.new(false)}
      # last elem
      |${|_, i| i}
      # check whether the elem is found one or just the last one of original iter
      |.{\ if &.^cond?}
  },
  # lazyMap works similar to map but returns iter of elements instead.
  lazyMap: m{|f| ._iter.{|it| <{yield it.next.^f}>}},
  # map is a wrapper of mapchain.
  map: m{|f| @^f},
  # max returns the maximum element in self
  max: m{.A.{\[1:]$(\[0]){|max, i| i if i > max else max}}},
  # min returns the minimum element in self
  min: m{.A.{\[1:]$(\[0]){|min, i| i if i < min else min}}},
  # reduce is a wrapper of reducechain.
  reduce: m{|f, init: nil| $(init)^f},
  # select selects elements for which f returns true.
  select: m{|f| @{\ if .proto == Arr else [\]}@{\.unwrap if f(*\)}},
  # sum returns sum of elements in self.
  sum: m{|| $(nil)+},
  # until returns elements while (element).^cond? is false.
  until: m{|cond?| ._iter.{|it| <{yield n if (n := it.next).^cond?.!}>}},
  # while returns elements while (element).^cond? is true.
  while: m{|cond?| ._iter.{|it| <{yield n if (n := it.next).^cond?}>}},
  # withI returns new iter of self with index.
  withI: m{._iter.{|it| <{|i| yield [i, it.next]; recur(i + 1)}>.new(0)}},
}
