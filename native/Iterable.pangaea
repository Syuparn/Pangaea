{
  # A converts self into arr.
  A: m{|| @{\}},
  # all? returns whether all elements meet the predicate f
  all?: m{|f| @^f@B.has?(false).!},
  # any? returns whether any element meets the predicate f
  any?: m{|f| @^f@B.has?(true)},
  # chain concatenates all iters in arguments.
  chain: m{
    iters := \0._iter
    <{|it|
      # NOTE: `yield if` cannot be used because it raises StopIterErr
      return next.val if (next := it.try.next).val?
      raise e if (e := next.err).type != StopIterErr
      # if StopIterErr is raised, use another iter
      nextIt := iters.next._iter
      yield nextIt.next
      recur(nextIt)
    }>.new(iters.next._iter)
  },
  # empty? returns whether self contains elements.
  empty?: m{|| .A.empty?},
  # exclude selects elements for which f returns false.
  exclude: m{|f| @{\ if .proto == Arr else [\]}@{\.unwrap if !f(*\)}},
  # lazyMap works similar to map but returns iter of elements instead.
  lazyMap: m{|f| ._iter.{|it| <{yield it.next.^f}>}},
  # map is a wrapper of mapchain.
  map: m{|f| @^f},
  # max returns the maximum element in self
  max: m{.A.{\[1:]$(\[0]){|max, i| i if i > max else max}}},
  # min returns the minimum element in self
  min: m{.A.{\[1:]$(\[0]){|min, i| i if i < min else min}}},
  # select selects elements for which f returns true.
  select: m{|f| @{\ if .proto == Arr else [\]}@{\.unwrap if f(*\)}},
  # sum returns sum of elements in self.
  sum: m{|| $(nil)+},
  # withI returns new iter of self with index.
  withI: m{._iter.{|it| <{|i| yield [i, it.next]; recur(i + 1)}>.new(0)}},
}
